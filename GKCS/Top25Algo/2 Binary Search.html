<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastering Binary Search</title>
    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .itepost-section-title {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            padding: 15px 20px;
            font-size: 1.8em;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            margin-top: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .itepost-section-content {
            background-color: white;
            padding: 25px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        .itepost-section-content p {
            margin-bottom: 16px;
        }
        pre {
            border-radius: 5px;
            margin: 15px 0;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
        }
        strong {
            color: #2E7D32;
        }
    </style>
</head>
<body>

<div class="itepost-section-title">Binary Search</div>
<div class="itepost-section-content">
  <p><strong>Category:</strong> Searching (Green)</p>
  
  <p><strong>Introduction:</strong> Binary Search is a fundamental "divide and conquer" algorithm used to efficiently find the position of a target value within a <strong>sorted array</strong>. Imagine looking for a word in a dictionary; you wouldn't start at 'A' and go page by page. Instead, you'd open it roughly in the middle and eliminate half of the remaining pages with each step. That's the power of Binary Search! It's crucial because it dramatically reduces search time, making it a cornerstone of efficient data retrieval in software.</p>
  
  <p><strong>Working Principle:</strong> The algorithm works by repeatedly dividing the search interval in half.
    <ol>
        <li>Start with the entire sorted array as the search space.</li>
        <li>Compare the target value to the middle element of the search space.</li>
        <li>If the target value matches the middle element, the position is returned.</li>
        <li>If the target value is less than the middle element, discard the right half and repeat the search on the left half.</li>
        <li>If the target value is greater than the middle element, discard the left half and repeat the search on the right half.</li>
        <li>This process continues until the value is found or the search space is empty.</li>
    </ol>
    <strong>Pseudocode:</strong><br>
    <code>
    function binary_search(arr, target) is<br>
    &nbsp;&nbsp;low = 0<br>
    &nbsp;&nbsp;high = length(arr) - 1<br>
    <br>
    &nbsp;&nbsp;while low <= high do<br>
    &nbsp;&nbsp;&nbsp;&nbsp;mid = low + (high - low) / 2  // Avoids potential overflow<br>
    &nbsp;&nbsp;&nbsp;&nbsp;if arr[mid] == target then<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mid<br>
    &nbsp;&nbsp;&nbsp;&nbsp;else if arr[mid] < target then<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low = mid + 1<br>
    &nbsp;&nbsp;&nbsp;&nbsp;else<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high = mid - 1<br>
    &nbsp;&nbsp;return NOT_FOUND
    </code>
  </p>
  
  <p><strong>Example & Dry Run:</strong><br>
    Let's search for the value <strong>23</strong> in the sorted array: <code>[2, 5, 8, 12, 16, 23, 38, 56, 72, 91]</code>.
    <ul>
        <li><strong>Step 1:</strong> low=0, high=9 → mid=4. arr[4]=16. 23 > 16, so search right. Set low = mid+1 = 5.</li>
        <li><strong>Step 2:</strong> low=5, high=9 → mid=7. arr[7]=56. 23 < 56, so search left. Set high = mid-1 = 6.</li>
        <li><strong>Step 3:</strong> low=5, high=6 → mid=5. arr[5]=23. Match found! Return index 5.</li>
    </ul>
    The target was found in just 3 steps, whereas a Linear Search would have taken 6.
  </p>
  
  <p><strong>Time and Space Complexity:</strong>
    <ul>
        <li><strong>Best Case:</strong> O(1) - The target is the middle element.</li>
        <li><strong>Average Case:</strong> O(log n) - The search space is halved with each step.</li>
        <li><strong>Worst Case:</strong> O(log n) - The element is not present or at the ends.</li>
        <li><strong>Space Complexity:</strong> O(1) for the iterative version (constant extra space). A recursive version would be O(log n) due to the call stack.</li>
    </ul>
  </p>
  
  <p><strong>Implementation in Multiple Languages:</strong></p>
  
  <pre><code class="language-c">// C Code Example (Iterative)
#include &lt;stdio.h&gt;

int binarySearch(int arr[], int size, int target) {
    int low = 0;
    int high = size - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target)
            return mid;
        if (arr[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1; // Not found
}

// Example usage:
// int arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};
// int n = sizeof(arr) / sizeof(arr[0]);
// int result = binarySearch(arr, n, 23);</code></pre>

  <pre><code class="language-cpp">// C++ Code Example (Iterative)
#include &lt;vector&gt;
using namespace std;

int binarySearch(vector&lt;int&gt;& arr, int target) {
    int low = 0;
    int high = arr.size() - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target)
            return mid;
        if (arr[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1; // Not found
}</code></pre>

  <pre><code class="language-csharp">// C# Code Example (Iterative)
using System;

public class Solution {
    public int BinarySearch(int[] arr, int target) {
        int low = 0;
        int high = arr.Length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] == target)
                return mid;
            if (arr[mid] < target)
                low = mid + 1;
            else
                high = mid - 1;
        }
        return -1; // Not found
    }
}</code></pre>

  <pre><code class="language-java">// Java Code Example (Iterative)
public class BinarySearch {
    public static int binarySearch(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] == target)
                return mid;
            if (arr[mid] < target)
                low = mid + 1;
            else
                high = mid - 1;
        }
        return -1; // Not found
    }
}</code></pre>

  <pre><code class="language-python"># Python Code Example (Iterative)
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = low + (high - low) // 2  # Use integer division
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1  # Not found

# Example usage:
# arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
# result = binary_search(arr, 23)</code></pre>

  <pre><code class="language-javascript">// JavaScript Code Example (Iterative)
function binarySearch(arr, target) {
    let low = 0;
    let high = arr.length - 1;

    while (low <= high) {
        let mid = Math.floor(low + (high - low) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1; // Not found
}

// Example usage:
// const arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91];
// const result = binarySearch(arr, 23);</code></pre>
  
  <p><strong>Practice Idea:</strong> Write a function that finds the first or last occurrence of a target value in a sorted array that may contain duplicates. For example, in <code>[1, 2, 2, 2, 3, 4]</code>, the first occurrence of <code>2</code> is at index 1, and the last is at index 3. This variation is a common interview question and deepens your understanding of Binary Search's logic.</p>
  
  <p><strong>Real-world Applications:</strong>
    <ul>
        <li><strong>Debugging:</strong> Used in "git bisect" to find the commit that introduced a bug.</li>
        <li><strong>Database Indexing:</strong> Databases use B-Trees (a generalization of Binary Search) for fast data retrieval.</li>
        <li><strong>Game Development:</strong> Finding a value in sorted leaderboards or asset lists.</li>
        <li><strong>Numerical Analysis:</strong> Finding roots of equations or performing range searches.</li>
        <li><strong>Word Suggestion/ Auto-complete:</strong> Quickly searching through a sorted dictionary of words.</li>
    </ul>
  </p>
  
  <p><strong>Summary:</strong> Binary Search is an essential algorithm that every programmer must master. Its incredible O(log n) efficiency for searching in sorted data makes it vastly superior to linear search for large datasets. Understanding its "divide and conquer" principle is a stepping stone to more complex algorithms and is a fundamental concept tested in technical interviews.</p>
</div>

<!-- Add this CSS -->
<style>
.code-language-buttons {
    margin-bottom: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.code-language-btn {
    padding: 5px 12px;
    background-color: #f1f1f1;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    transition: all 0.3s ease;
}

.code-language-btn:hover {
    background-color: #e9e9e9;
}

.code-language-btn.active {
    background-color: #4CAF50;
    color: white;
    border-color: #4CAF50;
}

.language-code-block {
    display: none;
}

.language-code-block.active {
    display: block;
}
</style>

<!-- Add this script after jQuery -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
$(document).ready(function() {
    // Process each implementation section
    $('.itepost-section-content').each(function() {
        const $section = $(this);
        const $implementationTitle = $section.find('p:contains("Implementation in Multiple Languages:")');
        
        if ($implementationTitle.length > 0) {
            const $codeBlocks = $implementationTitle.nextUntil('p').filter('pre');
            
            if ($codeBlocks.length > 0) {
                // Create language buttons container
                const $buttonsContainer = $('<div class="code-language-buttons"></div>');
                
                // Extract languages and create buttons
                const languages = [];
                $codeBlocks.each(function() {
                    const $codeBlock = $(this);
                    const languageClass = $codeBlock.find('code').attr('class');
                    let languageName = 'Unknown';
                    
                    if (languageClass) {
                        // Extract language name from class (e.g., "language-python" -> "python")
                        const match = languageClass.match(/language-(\w+)/);
                        if (match) {
                            languageName = match[1].toUpperCase();
                        }
                    }
                    
                    languages.push({
                        name: languageName,
                        element: $codeBlock
                    });
                    
                    // Add class to code block for easier selection
                    $codeBlock.addClass('language-code-block').addClass('lang-' + languageName.toLowerCase());
                });
                
                // Create buttons for each language
                languages.forEach((lang, index) => {
                    const $button = $('<button class="code-language-btn">' + lang.name + '</button>');
                    
                    // Make first button active by default
                    if (index === 0) {
                        $button.addClass('active');
                        lang.element.addClass('active');
                    }
                    
                    $button.on('click', function() {
                        // Remove active class from all buttons and code blocks
                        $buttonsContainer.find('.code-language-btn').removeClass('active');
                        $section.find('.language-code-block').removeClass('active');
                        
                        // Add active class to clicked button and corresponding code block
                        $(this).addClass('active');
                        lang.element.addClass('active');
                    });
                    
                    $buttonsContainer.append($button);
                });
                
                // Insert buttons after the implementation title
                $implementationTitle.after($buttonsContainer);
            }
        }
    });
});
</script>
</body>
</html>