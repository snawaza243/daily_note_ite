<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastering Binary Search</title>
    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }

        .itepost-section-title {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            padding: 15px 20px;
            font-size: 1.8em;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            margin-top: 30px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .itepost-section-content {
            background-color: white;
            padding: 25px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .itepost-section-content p {
            margin-bottom: 16px;
        }

        pre {
            border-radius: 5px;
            margin: 15px 0;
        }

        code {
            font-family: 'Consolas', 'Monaco', monospace;
        }

        strong {
            color: #2E7D32;
        }
    </style>

    <!-- Add this CSS -->
    <style>
        .code-language-buttons {
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .code-language-btn {
            padding: 5px 12px;
            background-color: #f1f1f1;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .code-language-btn:hover {
            background-color: #e9e9e9;
        }

        .code-language-btn.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .language-code-block {
            display: none;
        }

        .language-code-block.active {
            display: block;
        }
    </style>

    <!-- Add this script after jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        $(document).ready(function () {
            // Process each implementation section
            $('.itepost-section-content').each(function () {
                const $section = $(this);
                const $implementationTitle = $section.find('p:contains("Implementation in Multiple Languages:")');

                if ($implementationTitle.length > 0) {
                    const $codeBlocks = $implementationTitle.nextUntil('p').filter('pre');

                    if ($codeBlocks.length > 0) {
                        // Create language buttons container
                        const $buttonsContainer = $('<div class="code-language-buttons"></div>');

                        // Extract languages and create buttons
                        const languages = [];
                        $codeBlocks.each(function () {
                            const $codeBlock = $(this);
                            const languageClass = $codeBlock.find('code').attr('class');
                            let languageName = 'Unknown';

                            if (languageClass) {
                                // Extract language name from class (e.g., "language-python" -> "python")
                                const match = languageClass.match(/language-(\w+)/);
                                if (match) {
                                    languageName = match[1].toUpperCase();
                                }
                            }

                            languages.push({
                                name: languageName,
                                element: $codeBlock
                            });

                            // Add class to code block for easier selection
                            $codeBlock.addClass('language-code-block').addClass('lang-' + languageName.toLowerCase());
                        });

                        // Create buttons for each language
                        languages.forEach((lang, index) => {
                            const $button = $('<button class="code-language-btn">' + lang.name + '</button>');

                            // Make first button active by default
                            if (index === 0) {
                                $button.addClass('active');
                                lang.element.addClass('active');
                            }

                            $button.on('click', function () {
                                // Remove active class from all buttons and code blocks
                                $buttonsContainer.find('.code-language-btn').removeClass('active');
                                $section.find('.language-code-block').removeClass('active');

                                // Add active class to clicked button and corresponding code block
                                $(this).addClass('active');
                                lang.element.addClass('active');
                            });

                            $buttonsContainer.append($button);
                        });

                        // Insert buttons after the implementation title
                        $implementationTitle.after($buttonsContainer);
                    }
                }
            });
        });

    </script>
</head>
 
<body>
    <div class="itepost-section-title">Quick Sort</div>
    <div class="itepost-section-content">
      <p><strong>Category:</strong> Sorting (Green)</p>
      
      <p><strong>Introduction:</strong> Quick Sort is a highly efficient, divide-and-conquer sorting algorithm that works by selecting a 'pivot' element and partitioning the array around it. Elements smaller than the pivot go to its left, and elements greater go to its right. The algorithm then recursively sorts the sub-arrays. Known for its excellent average-case performance O(n log n), Quick Sort is often the preferred choice for general-purpose sorting and is widely used in practice due to its cache efficiency and in-place sorting capability.</p>
      
      <p><strong>Working Principle:</strong> The algorithm follows these key steps:
        <ol>
            <li><strong>Choose Pivot:</strong> Select an element from the array as the pivot</li>
            <li><strong>Partition:</strong> Rearrange the array so all elements smaller than pivot come before it, and all greater elements come after it</li>
            <li><strong>Recurse:</strong> Recursively apply the above steps to the sub-arrays on both sides of the pivot</li>
            <li><strong>Base Case:</strong> Arrays of size 0 or 1 are already sorted</li>
        </ol>
        <strong>Pseudocode:</strong><br>
        <code>
        quickSort(arr, low, high):<br>
        &nbsp;&nbsp;if low < high:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// pi is partitioning index<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pi = partition(arr, low, high)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Recursively sort elements before and after partition<br>
        &nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr, low, pi - 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr, pi + 1, high)<br>
        <br>
        partition(arr, low, high):<br>
        &nbsp;&nbsp;pivot = arr[high]  // Choosing last element as pivot<br>
        &nbsp;&nbsp;i = low - 1  // Index of smaller element<br>
        &nbsp;&nbsp;<br>
        &nbsp;&nbsp;for j from low to high-1:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if arr[j] <= pivot:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = i + 1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap arr[i] and arr[j]<br>
        &nbsp;&nbsp;<br>
        &nbsp;&nbsp;swap arr[i + 1] and arr[high]<br>
        &nbsp;&nbsp;return i + 1<br>
        </code>
      </p>
      
      <p><strong>Example & Dry Run:</strong><br>
        Let's sort the array: <code>[10, 80, 30, 90, 40, 50, 70]</code> with pivot as last element (70)
        <ul>
            <li><strong>Partition 1:</strong> Pivot=70 → [10, 30, 40, 50, 70, 90, 80] → Pivot index=4</li>
            <li><strong>Left Subarray:</strong> [10, 30, 40, 50] → Pivot=50 → [10, 30, 40, 50]</li>
            <li><strong>Left-Left:</strong> [10, 30, 40] → Pivot=40 → [10, 30, 40]</li>
            <li><strong>Left-Left-Left:</strong> [10, 30] → Pivot=30 → [10, 30]</li>
            <li><strong>Right Subarray:</strong> [90, 80] → Pivot=80 → [80, 90]</li>
            <li><strong>Result:</strong> Sorted array: <code>[10, 30, 40, 50, 70, 80, 90]</code></li>
        </ul>
      </p>
      
      <p><strong>Time and Space Complexity:</strong>
        <ul>
            <li><strong>Best Case:</strong> O(n log n) - When pivot divides array into equal halves</li>
            <li><strong>Average Case:</strong> O(n log n) - Expected performance for random data</li>
            <li><strong>Worst Case:</strong> O(n²) - When pivot is always smallest or largest element</li>
            <li><strong>Space Complexity:</strong> O(log n) - Due to recursion stack (can be O(n) in worst case)</li>
        </ul>
      </p>
      
      <p><strong>Implementation in Multiple Languages:</strong></p>
      
      <div class="code-language-buttons">
        <button class="code-language-btn active" data-language="c">C</button>
        <button class="code-language-btn" data-language="cpp">C++</button>
        <button class="code-language-btn" data-language="csharp">C#</button>
        <button class="code-language-btn" data-language="java">Java</button>
        <button class="code-language-btn" data-language="python">Python</button>
        <button class="code-language-btn" data-language="javascript">JavaScript</button>
      </div>
      
      <div class="language-code-block active" id="c-code">
        <pre><code class="language-c">// C Code Example
#include &lt;stdio.h&gt;

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Lomuto partition scheme
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // Choose last element as pivot
    int i = (low - 1);      // Index of smaller element
    
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

// Hoare partition scheme (generally more efficient)
int partitionHoare(int arr[], int low, int high) {
    int pivot = arr[low];
    int i = low - 1;
    int j = high + 1;
    
    while (1) {
        do {
            i++;
        } while (arr[i] < pivot);
        
        do {
            j--;
        } while (arr[j] > pivot);
        
        if (i >= j) return j;
        
        swap(&arr[i], &arr[j]);
    }
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // pi is partitioning index
        int pi = partition(arr, low, high);
        
        // Recursively sort elements before and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Iterative Quick Sort using stack
void quickSortIterative(int arr[], int low, int high) {
    int stack[high - low + 1];
    int top = -1;
    
    stack[++top] = low;
    stack[++top] = high;
    
    while (top >= 0) {
        high = stack[top--];
        low = stack[top--];
        
        int pi = partition(arr, low, high);
        
        if (pi - 1 > low) {
            stack[++top] = low;
            stack[++top] = pi - 1;
        }
        
        if (pi + 1 < high) {
            stack[++top] = pi + 1;
            stack[++top] = high;
        }
    }
}

// Example usage:
// int arr[] = {10, 80, 30, 90, 40, 50, 70};
// int n = sizeof(arr) / sizeof(arr[0]);
// quickSort(arr, 0, n - 1);</code></pre>
      </div>

      <div class="language-code-block" id="cpp-code">
        <pre><code class="language-cpp">// C++ Code Example
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;iostream&gt;
using namespace std;

// Lomuto partition scheme
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// Median-of-three pivot selection
int medianOfThree(vector<int>& arr, int low, int high) {
    int mid = low + (high - low) / 2;
    
    if (arr[low] > arr[mid]) swap(arr[low], arr[mid]);
    if (arr[low] > arr[high]) swap(arr[low], arr[high]);
    if (arr[mid] > arr[high]) swap(arr[mid], arr[high]);
    
    return mid;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        // Use median-of-three for better pivot selection
        int pivotIndex = medianOfThree(arr, low, high);
        swap(arr[pivotIndex], arr[high]);
        
        int pi = partition(arr, low, high);
        
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Template version for different data types
template<typename T>
void quickSortGeneric(vector<T>& arr, int low, int high) {
    if (low < high) {
        T pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr[i], arr[j]);
            }
        }
        swap(arr[i + 1], arr[high]);
        int pi = i + 1;
        
        quickSortGeneric(arr, low, pi - 1);
        quickSortGeneric(arr, pi + 1, high);
    }
}

// Iterative Quick Sort
void quickSortIterative(vector<int>& arr, int low, int high) {
    stack<pair<int, int>> st;
    st.push({low, high});
    
    while (!st.empty()) {
        auto [l, h] = st.top();
        st.pop();
        
        if (l < h) {
            int pi = partition(arr, l, h);
            
            if (pi - 1 > l) st.push({l, pi - 1});
            if (pi + 1 < h) st.push({pi + 1, h});
        }
    }
}

// Example usage:
// vector<int> arr = {10, 80, 30, 90, 40, 50, 70};
// quickSort(arr, 0, arr.size() - 1);</code></pre>
      </div>

      <div class="language-code-block" id="csharp-code">
        <pre><code class="language-csharp">// C# Code Example
using System;
using System.Collections.Generic;

public class QuickSort {
    // Lomuto partition scheme
    private static int Partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                (arr[i], arr[j]) = (arr[j], arr[i]);
            }
        }
        (arr[i + 1], arr[high]) = (arr[high], arr[i + 1]);
        return i + 1;
    }
    
    // Hoare partition scheme
    private static int PartitionHoare(int[] arr, int low, int high) {
        int pivot = arr[low];
        int i = low - 1;
        int j = high + 1;
        
        while (true) {
            do {
                i++;
            } while (arr[i] < pivot);
            
            do {
                j--;
            } while (arr[j] > pivot);
            
            if (i >= j) return j;
            
            (arr[i], arr[j]) = (arr[j], arr[i]);
        }
    }
    
    public static void Sort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = Partition(arr, low, high);
            
            Sort(arr, low, pi - 1);
            Sort(arr, pi + 1, high);
        }
    }
    
    // Three-way partition for arrays with many duplicates (Dutch National Flag)
    private static (int, int) ThreeWayPartition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low;
        int j = low;
        int k = high;
        
        while (j <= k) {
            if (arr[j] < pivot) {
                (arr[i], arr[j]) = (arr[j], arr[i]);
                i++;
                j++;
            } else if (arr[j] > pivot) {
                (arr[j], arr[k]) = (arr[k], arr[j]);
                k--;
            } else {
                j++;
            }
        }
        return (i, k);
    }
    
    public static void ThreeWayQuickSort(int[] arr, int low, int high) {
        if (low < high) {
            var (left, right) = ThreeWayPartition(arr, low, high);
            ThreeWayQuickSort(arr, low, left - 1);
            ThreeWayQuickSort(arr, right + 1, high);
        }
    }
    
    // Iterative Quick Sort
    public static void SortIterative(int[] arr) {
        Stack<(int, int)> stack = new Stack<(int, int)>();
        stack.Push((0, arr.Length - 1));
        
        while (stack.Count > 0) {
            var (low, high) = stack.Pop();
            
            if (low < high) {
                int pi = Partition(arr, low, high);
                
                if (pi - 1 > low) stack.Push((low, pi - 1));
                if (pi + 1 < high) stack.Push((pi + 1, high));
            }
        }
    }
}

// Example usage:
// int[] arr = {10, 80, 30, 90, 40, 50, 70};
// QuickSort.Sort(arr, 0, arr.Length - 1);</code></pre>
      </div>

      <div class="language-code-block" id="java-code">
        <pre><code class="language-java">// Java Code Example
import java.util.Stack;

public class QuickSort {
    // Lomuto partition scheme
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        
        return i + 1;
    }
    
    // Randomized pivot selection to avoid worst-case
    private static int randomizedPartition(int[] arr, int low, int high) {
        int randomIndex = low + (int)(Math.random() * (high - low + 1));
        int temp = arr[randomIndex];
        arr[randomIndex] = arr[high];
        arr[high] = temp;
        
        return partition(arr, low, high);
    }
    
    public static void sort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = randomizedPartition(arr, low, high);
            
            sort(arr, low, pi - 1);
            sort(arr, pi + 1, high);
        }
    }
    
    // Generic version for Comparable objects
    public static <T extends Comparable<T>> void sortGeneric(T[] arr, int low, int high) {
        if (low < high) {
            T pivot = arr[high];
            int i = low - 1;
            
            for (int j = low; j < high; j++) {
                if (arr[j].compareTo(pivot) <= 0) {
                    i++;
                    T temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            
            T temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            int pi = i + 1;
            
            sortGeneric(arr, low, pi - 1);
            sortGeneric(arr, pi + 1, high);
        }
    }
    
    // Iterative Quick Sort
    public static void sortIterative(int[] arr) {
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        stack.push(arr.length - 1);
        
        while (!stack.isEmpty()) {
            int high = stack.pop();
            int low = stack.pop();
            
            if (low < high) {
                int pi = partition(arr, low, high);
                
                if (pi - 1 > low) {
                    stack.push(low);
                    stack.push(pi - 1);
                }
                
                if (pi + 1 < high) {
                    stack.push(pi + 1);
                    stack.push(high);
                }
            }
        }
    }
    
    // Quick sort with insertion sort optimization for small arrays
    public static void optimizedSort(int[] arr, int low, int high) {
        while (low < high) {
            // Use insertion sort for small arrays
            if (high - low < 10) {
                insertionSort(arr, low, high);
                break;
            } else {
                int pi = randomizedPartition(arr, low, high);
                
                // Recurse for smaller subarray first to limit stack depth
                if (pi - low < high - pi) {
                    optimizedSort(arr, low, pi - 1);
                    low = pi + 1;
                } else {
                    optimizedSort(arr, pi + 1, high);
                    high = pi - 1;
                }
            }
        }
    }
    
    private static void insertionSort(int[] arr, int low, int high) {
        for (int i = low + 1; i <= high; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= low && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {10, 80, 30, 90, 40, 50, 70};
        sort(arr, 0, arr.length - 1);
    }
}</code></pre>
      </div>

      <div class="language-code-block" id="python-code">
        <pre><code class="language-python"># Python Code Example
def quick_sort(arr, low=0, high=None):
    """
    Sorts an array using quick sort algorithm (Lomuto partition scheme).
    
    Args:
        arr: List of comparable elements
        low: Starting index
        high: Ending index
    
    Returns:
        The sorted list (in-place sort)
    """
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        # Partition the array and get pivot index
        pi = partition(arr, low, high)
        
        # Recursively sort elements before and after partition
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)
    
    return arr

def partition(arr, low, high):
    """Lomuto partition scheme"""
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Hoare partition scheme
def partition_hoare(arr, low, high):
    pivot = arr[low]
    i = low - 1
    j = high + 1
    
    while True:
        i += 1
        while arr[i] < pivot:
            i += 1
        
        j -= 1
        while arr[j] > pivot:
            j -= 1
        
        if i >= j:
            return j
        
        arr[i], arr[j] = arr[j], arr[i]

# Three-way quick sort for arrays with duplicates
def three_way_quick_sort(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        left, right = three_way_partition(arr, low, high)
        three_way_quick_sort(arr, low, left - 1)
        three_way_quick_sort(arr, right + 1, high)
    
    return arr

def three_way_partition(arr, low, high):
    pivot = arr[high]
    i = low
    j = low
    k = high
    
    while j <= k:
        if arr[j] < pivot:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            j += 1
        elif arr[j] > pivot:
            arr[j], arr[k] = arr[k], arr[j]
            k -= 1
        else:
            j += 1
    
    return i, k

# Iterative quick sort
def quick_sort_iterative(arr):
    stack = [(0, len(arr) - 1)]
    
    while stack:
        low, high = stack.pop()
        
        if low < high:
            pi = partition(arr, low, high)
            
            if pi - 1 > low:
                stack.append((low, pi - 1))
            if pi + 1 < high:
                stack.append((pi + 1, high))
    
    return arr

# Optimized quick sort with insertion sort for small arrays
def optimized_quick_sort(arr, low=0, high=None, threshold=10):
    if high is None:
        high = len(arr) - 1
    
    while low < high:
        if high - low < threshold:
            insertion_sort(arr, low, high)
            break
        else:
            pi = partition(arr, low, high)
            
            # Recurse on smaller subarray first
            if pi - low < high - pi:
                optimized_quick_sort(arr, low, pi - 1, threshold)
                low = pi + 1
            else:
                optimized_quick_sort(arr, pi + 1, high, threshold)
                high = pi - 1
    
    return arr

def insertion_sort(arr, low, high):
    for i in range(low + 1, high + 1):
        key = arr[i]
        j = i - 1
        while j >= low and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Example usage:
# arr = [10, 80, 30, 90, 40, 50, 70]
# quick_sort(arr)
# print(arr)  # Output: [10, 30, 40, 50, 70, 80, 90]</code></pre>
      </div>

      <div class="language-code-block" id="javascript-code">
        <pre><code class="language-javascript">// JavaScript Code Example
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        // Partition the array and get pivot index
        const pi = partition(arr, low, high);
        
        // Recursively sort elements before and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    // Lomuto partition scheme
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}

// Hoare partition scheme
function partitionHoare(arr, low, high) {
    const pivot = arr[low];
    let i = low - 1;
    let j = high + 1;
    
    while (true) {
        do {
            i++;
        } while (arr[i] < pivot);
        
        do {
            j--;
        } while (arr[j] > pivot);
        
        if (i >= j) return j;
        
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

// Three-way quick sort for arrays with duplicates
function threeWayQuickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const [left, right] = threeWayPartition(arr, low, high);
        threeWayQuickSort(arr, low, left - 1);
        threeWayQuickSort(arr, right + 1, high);
    }
    return arr;
}

function threeWayPartition(arr, low, high) {
    const pivot = arr[high];
    let i = low;
    let j = low;
    let k = high;
    
    while (j <= k) {
        if (arr[j] < pivot) {
            [arr[i], arr[j]] = [arr[j], arr[i]];
            i++;
            j++;
        } else if (arr[j] > pivot) {
            [arr[j], arr[k]] = [arr[k], arr[j]];
            k--;
        } else {
            j++;
        }
    }
    return [i, k];
}

// Iterative quick sort
function quickSortIterative(arr) {
    const stack = [[0, arr.length - 1]];
    
    while (stack.length) {
        const [low, high] = stack.pop();
        
        if (low < high) {
            const pi = partition(arr, low, high);
            
            if (pi - 1 > low) {
                stack.push([low, pi - 1]);
            }
            if (pi + 1 < high) {
                stack.push([pi + 1, high]);
            }
        }
    }
    return arr;
}

// Optimized quick sort with insertion sort for small arrays
function optimizedQuickSort(arr, low = 0, high = arr.length - 1, threshold = 10) {
    while (low < high) {
        if (high - low < threshold) {
            insertionSort(arr, low, high);
            break;
        } else {
            const pi = partition(arr, low, high);
            
            // Recurse on smaller subarray first
            if (pi - low < high - pi) {
                optimizedQuickSort(arr, low, pi - 1, threshold);
                low = pi + 1;
            } else {
                optimizedQuickSort(arr, pi + 1, high, threshold);
                high = pi - 1;
            }
        }
    }
    return arr;
}

function insertionSort(arr, low, high) {
    for (let i = low + 1; i <= high; i++) {
        const key = arr[i];
        let j = i - 1;
        
        while (j >= low && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

// Functional programming style (immutable)
function quickSortImmutable(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[arr.length - 1];
    const left = [];
    const right = [];
    
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] <= pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    
    return [...quickSortImmutable(left), pivot, ...quickSortImmutable(right)];
}

// Example usage:
// const arr = [10, 80, 30, 90, 40, 50, 70];
// quickSort(arr);
// console.log(arr);  // Output: [10, 30, 40, 50, 70, 80, 90]</code></pre>
      </div>
      
      <p><strong>Practice Idea:</strong> Implement different pivot selection strategies (first element, last element, median-of-three, random) and compare their performance on various input types. Then, create a hybrid Quick Sort that switches to Insertion Sort for small subarrays (typically less than 10 elements) to optimize performance.</p>
      
      <p><strong>Real-world Applications:</strong>
        <ul>
            <li><strong>General-Purpose Sorting:</strong> Widely used in programming language libraries (C++ STL, Java Collections, Python sorted)</li>
            <li><strong>Database Systems:</strong> Used for sorting query results and index creation</li>
            <li><strong>File Systems:</strong> Sorting directory listings and file metadata</li>
            <li><strong>Scientific Computing:</strong> Sorting large datasets for analysis and visualization</li>
            <li><strong>Machine Learning:</strong> Preprocessing data and sorting feature importance</li>
            <li><strong>Competitive Programming:</strong> Preferred for its excellent average-case performance</li>
            <li><strong>Operating Systems:</strong> Process scheduling and memory management</li>
            <li><strong>Graphics Rendering:</strong> Sorting polygons and objects by depth</li>
        </ul>
      </p>
      
      <p><strong>Summary:</strong> Quick Sort is one of the most efficient and widely used sorting algorithms in practice. Its O(n log n) average-case performance, in-place sorting capability, and cache efficiency make it ideal for large datasets. While it has a worst-case O(n²) time complexity, this can be mitigated through proper pivot selection strategies. Understanding Quick Sort is essential for any programmer, as it demonstrates powerful divide-and-conquer techniques and forms the basis for many optimized sorting implementations.</p>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const languageButtons = document.querySelectorAll('.code-language-btn');
        const codeBlocks = document.querySelectorAll('.language-code-block');
        
        languageButtons.forEach(button => {
            button.addEventListener('click', function() {
                const targetLanguage = this.getAttribute('data-language');
                
                // Update active button
                languageButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                
                // Show corresponding code block
                codeBlocks.forEach(block => {
                    if (block.id === `${targetLanguage}-code`) {
                        block.classList.add('active');
                    } else {
                        block.classList.remove('active');
                    }
                });
            });
        });
    });
    </script>
</body>
</html>