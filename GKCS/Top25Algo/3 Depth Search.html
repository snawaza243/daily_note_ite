<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastering Binary Search</title>
    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .itepost-section-title {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            padding: 15px 20px;
            font-size: 1.8em;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            margin-top: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .itepost-section-content {
            background-color: white;
            padding: 25px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        .itepost-section-content p {
            margin-bottom: 16px;
        }
        pre {
            border-radius: 5px;
            margin: 15px 0;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
        }
        strong {
            color: #2E7D32;
        }
    </style>

    <!-- Add this CSS -->
<style>
.code-language-buttons {
    margin-bottom: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.code-language-btn {
    padding: 5px 12px;
    background-color: #f1f1f1;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    transition: all 0.3s ease;
}

.code-language-btn:hover {
    background-color: #e9e9e9;
}

.code-language-btn.active {
    background-color: #4CAF50;
    color: white;
    border-color: #4CAF50;
}

.language-code-block {
    display: none;
}

.language-code-block.active {
    display: block;
}
</style>

<!-- Add this script after jQuery -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
$(document).ready(function() {
    // Process each implementation section
    $('.itepost-section-content').each(function() {
        const $section = $(this);
        const $implementationTitle = $section.find('p:contains("Implementation in Multiple Languages:")');
        
        if ($implementationTitle.length > 0) {
            const $codeBlocks = $implementationTitle.nextUntil('p').filter('pre');
            
            if ($codeBlocks.length > 0) {
                // Create language buttons container
                const $buttonsContainer = $('<div class="code-language-buttons"></div>');
                
                // Extract languages and create buttons
                const languages = [];
                $codeBlocks.each(function() {
                    const $codeBlock = $(this);
                    const languageClass = $codeBlock.find('code').attr('class');
                    let languageName = 'Unknown';
                    
                    if (languageClass) {
                        // Extract language name from class (e.g., "language-python" -> "python")
                        const match = languageClass.match(/language-(\w+)/);
                        if (match) {
                            languageName = match[1].toUpperCase();
                        }
                    }
                    
                    languages.push({
                        name: languageName,
                        element: $codeBlock
                    });
                    
                    // Add class to code block for easier selection
                    $codeBlock.addClass('language-code-block').addClass('lang-' + languageName.toLowerCase());
                });
                
                // Create buttons for each language
                languages.forEach((lang, index) => {
                    const $button = $('<button class="code-language-btn">' + lang.name + '</button>');
                    
                    // Make first button active by default
                    if (index === 0) {
                        $button.addClass('active');
                        lang.element.addClass('active');
                    }
                    
                    $button.on('click', function() {
                        // Remove active class from all buttons and code blocks
                        $buttonsContainer.find('.code-language-btn').removeClass('active');
                        $section.find('.language-code-block').removeClass('active');
                        
                        // Add active class to clicked button and corresponding code block
                        $(this).addClass('active');
                        lang.element.addClass('active');
                    });
                    
                    $buttonsContainer.append($button);
                });
                
                // Insert buttons after the implementation title
                $implementationTitle.after($buttonsContainer);
            }
        }
    });
});

</script>
</head>
<body>
    <div class="itepost-section-title">Depth-First Search (DFS)</div>
    <div class="itepost-section-content">
      <p><strong>Category:</strong> Searching (Green)</p>
      
      <p><strong>Introduction:</strong> Depth-First Search (DFS) is a fundamental graph traversal algorithm that explores as far as possible along each branch before backtracking. Imagine exploring a maze by always taking the leftmost path until you hit a dead end, then backtracking to the last decision point. DFS is used for pathfinding, cycle detection, topological sorting, and solving puzzles. It's a building block for many complex algorithms in computer science.</p>
      
      <p><strong>Working Principle:</strong> DFS uses a stack (either explicitly or via recursion) to keep track of vertices to visit:
        <ol>
            <li>Start at the root node (or an arbitrary node for graphs) and mark it as visited.</li>
            <li>Explore each adjacent unvisited node, moving deeper into the graph.</li>
            <li>When you reach a node with no unvisited neighbors, backtrack to the previous node.</li>
            <li>Repeat until all reachable nodes have been visited.</li>
        </ol>
        <strong>Pseudocode (Recursive):</strong><br>
        <code>
        DFS(graph, node, visited):<br>
        &nbsp;&nbsp;if node is visited: return<br>
        &nbsp;&nbsp;mark node as visited<br>
        &nbsp;&nbsp;process(node)  // e.g., print or store<br>
        &nbsp;&nbsp;for each neighbor in graph[node]:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if neighbor not visited:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DFS(graph, neighbor, visited)<br>
        </code>
        <br>
        <strong>Pseudocode (Iterative):</strong><br>
        <code>
        DFS(graph, start):<br>
        &nbsp;&nbsp;stack = [start]<br>
        &nbsp;&nbsp;visited = set()<br>
        &nbsp;&nbsp;while stack not empty:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;node = stack.pop()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if node not visited:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(node)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process(node)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor in graph[node]:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor not visited:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(neighbor)<br>
        </code>
      </p>
      
      <p><strong>Example & Dry Run:</strong><br>
        Consider this graph represented as an adjacency list:<br>
        <code>
        A: [B, C]<br>
        B: [A, D, E]<br>
        C: [A, F]<br>
        D: [B]<br>
        E: [B, F]<br>
        F: [C, E]<br>
        </code>
        Starting from node A, DFS traversal (recursive):
        <ul>
            <li><strong>Step 1:</strong> Visit A → Mark visited</li>
            <li><strong>Step 2:</strong> From A, go to B → Mark visited</li>
            <li><strong>Step 3:</strong> From B, go to D → Mark visited</li>
            <li><strong>Step 4:</strong> D has no unvisited neighbors, backtrack to B</li>
            <li><strong>Step 5:</strong> From B, go to E → Mark visited</li>
            <li><strong>Step 6:</strong> From E, go to F → Mark visited</li>
            <li><strong>Step 7:</strong> From F, go to C → Mark visited</li>
            <li><strong>Result:</strong> Traversal order: A → B → D → E → F → C</li>
        </ul>
      </p>
      
      <p><strong>Time and Space Complexity:</strong>
        <ul>
            <li><strong>Time Complexity:</strong> O(V + E) where V is vertices and E is edges</li>
            <li><strong>Space Complexity:</strong> O(V) for storing visited set and recursion stack</li>
            <li><strong>Best Case:</strong> O(1) - Target node is the start node</li>
            <li><strong>Worst Case:</strong> O(V + E) - Traverse entire graph</li>
        </ul>
      </p>
      
      <p><strong>Implementation in Multiple Languages:</strong></p>
      
      <div class="code-language-buttons">
        <button class="code-language-btn active" data-language="c">C</button>
        <button class="code-language-btn" data-language="cpp">C++</button>
        <button class="code-language-btn" data-language="csharp">C#</button>
        <button class="code-language-btn" data-language="java">Java</button>
        <button class="code-language-btn" data-language="python">Python</button>
        <button class="code-language-btn" data-language="javascript">JavaScript</button>
      </div>
      
      <div class="language-code-block active" id="c-code">
        <pre><code class="language-c">// C Code Example (Iterative DFS)
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX 100

int graph[MAX][MAX];
int visited[MAX];
int stack[MAX];
int top = -1;

void push(int node) {
    stack[++top] = node;
}

int pop() {
    return stack[top--];
}

int isEmpty() {
    return top == -1;
}

void dfs(int start, int n) {
    push(start);
    
    while (!isEmpty()) {
        int current = pop();
        
        if (!visited[current]) {
            printf("%d ", current);
            visited[current] = 1;
            
            for (int i = n-1; i >= 0; i--) {
                if (graph[current][i] && !visited[i]) {
                    push(i);
                }
            }
        }
    }
}

// Example usage:
// Initialize graph with edges
// dfs(0, 5); // Start from node 0 with 5 nodes total</code></pre>
      </div>

      <div class="language-code-block" id="cpp-code">
        <pre><code class="language-cpp">// C++ Code Example (Recursive DFS)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
using namespace std;

void dfsRecursive(const vector<vector<int>>& graph, int node, 
                  unordered_set<int>& visited) {
    if (visited.find(node) != visited.end()) return;
    
    visited.insert(node);
    cout << node << " ";  // Process the node
    
    for (int neighbor : graph[node]) {
        if (visited.find(neighbor) == visited.end()) {
            dfsRecursive(graph, neighbor, visited);
        }
    }
}

// Iterative DFS
void dfsIterative(const vector<vector<int>>& graph, int start) {
    unordered_set<int> visited;
    vector<int> stack = {start};
    
    while (!stack.empty()) {
        int node = stack.back();
        stack.pop_back();
        
        if (visited.find(node) == visited.end()) {
            visited.insert(node);
            cout << node << " ";
            
            // Add neighbors in reverse to maintain order
            for (auto it = graph[node].rbegin(); it != graph[node].rend(); ++it) {
                if (visited.find(*it) == visited.end()) {
                    stack.push_back(*it);
                }
            }
        }
    }
}

// Example usage:
// vector<vector<int>> graph = {{1,2}, {0,3,4}, {0,5}, {1}, {1,5}, {2,4}};
// dfsRecursive(graph, 0, unordered_set<int>());</code></pre>
      </div>

      <div class="language-code-block" id="csharp-code">
        <pre><code class="language-csharp">// C# Code Example (Recursive DFS)
using System;
using System.Collections.Generic;

public class DFS {
    public static void DfsRecursive(Dictionary<int, List<int>> graph, 
                                   int node, HashSet<int> visited) {
        if (visited.Contains(node)) return;
        
        visited.Add(node);
        Console.Write(node + " ");  // Process the node
        
        foreach (int neighbor in graph[node]) {
            if (!visited.Contains(neighbor)) {
                DfsRecursive(graph, neighbor, visited);
            }
        }
    }
    
    public static void DfsIterative(Dictionary<int, List<int>> graph, int start) {
        HashSet<int> visited = new HashSet<int>();
        Stack<int> stack = new Stack<int>();
        stack.Push(start);
        
        while (stack.Count > 0) {
            int node = stack.Pop();
            
            if (!visited.Contains(node)) {
                visited.Add(node);
                Console.Write(node + " ");
                
                // Push neighbors in reverse order to maintain traversal order
                for (int i = graph[node].Count - 1; i >= 0; i--) {
                    if (!visited.Contains(graph[node][i])) {
                        stack.Push(graph[node][i]);
                    }
                }
            }
        }
    }
}

// Example usage:
// var graph = new Dictionary<int, List<int>> {
//     {0, new List<int> {1, 2}},
//     {1, new List<int> {0, 3, 4}},
//     {2, new List<int> {0, 5}},
//     {3, new List<int> {1}},
//     {4, new List<int> {1, 5}},
//     {5, new List<int> {2, 4}}
// };
// DFS.DfsRecursive(graph, 0, new HashSet<int>());</code></pre>
      </div>

      <div class="language-code-block" id="java-code">
        <pre><code class="language-java">// Java Code Example (Recursive DFS)
import java.util.*;

public class DepthFirstSearch {
    // Recursive DFS
    public static void dfsRecursive(Map<Integer, List<Integer>> graph, 
                                   int node, Set<Integer> visited) {
        if (visited.contains(node)) return;
        
        visited.add(node);
        System.out.print(node + " ");  // Process the node
        
        for (int neighbor : graph.get(node)) {
            if (!visited.contains(neighbor)) {
                dfsRecursive(graph, neighbor, visited);
            }
        }
    }
    
    // Iterative DFS
    public static void dfsIterative(Map<Integer, List<Integer>> graph, int start) {
        Set<Integer> visited = new HashSet<>();
        Stack<Integer> stack = new Stack<>();
        stack.push(start);
        
        while (!stack.isEmpty()) {
            int node = stack.pop();
            
            if (!visited.contains(node)) {
                visited.add(node);
                System.out.print(node + " ");
                
                // Push neighbors in reverse order
                List<Integer> neighbors = graph.get(node);
                for (int i = neighbors.size() - 1; i >= 0; i--) {
                    if (!visited.contains(neighbors.get(i))) {
                        stack.push(neighbors.get(i));
                    }
                }
            }
        }
    }
    
    public static void main(String[] args) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(0, Arrays.asList(1, 2));
        graph.put(1, Arrays.asList(0, 3, 4));
        graph.put(2, Arrays.asList(0, 5));
        graph.put(3, Arrays.asList(1));
        graph.put(4, Arrays.asList(1, 5));
        graph.put(5, Arrays.asList(2, 4));
        
        dfsRecursive(graph, 0, new HashSet<>());
    }
}</code></pre>
      </div>

      <div class="language-code-block" id="python-code">
        <pre><code class="language-python"># Python Code Example (Recursive DFS)
def dfs_recursive(graph, node, visited=None):
    if visited is None:
        visited = set()
    
    if node in visited:
        return
    
    visited.add(node)
    print(node, end=' ')  # Process the node
    
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

# Iterative DFS
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            print(node, end=' ')
            # Add neighbors in reverse to maintain order
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)

# Example usage:
# graph = {
#     0: [1, 2],
#     1: [0, 3, 4],
#     2: [0, 5],
#     3: [1],
#     4: [1, 5],
#     5: [2, 4]
# }
# dfs_recursive(graph, 0)</code></pre>
      </div>

      <div class="language-code-block" id="javascript-code">
        <pre><code class="language-javascript">// JavaScript Code Example (Recursive DFS)
function dfsRecursive(graph, node, visited = new Set()) {
    if (visited.has(node)) return;
    
    visited.add(node);
    console.log(node);  // Process the node
    
    for (const neighbor of graph[node]) {
        if (!visited.has(neighbor)) {
            dfsRecursive(graph, neighbor, visited);
        }
    }
}

// Iterative DFS
function dfsIterative(graph, start) {
    const visited = new Set();
    const stack = [start];
    
    while (stack.length > 0) {
        const node = stack.pop();
        
        if (!visited.has(node)) {
            visited.add(node);
            console.log(node);
            
            // Add neighbors in reverse to maintain order
            for (let i = graph[node].length - 1; i >= 0; i--) {
                if (!visited.has(graph[node][i])) {
                    stack.push(graph[node][i]);
                }
            }
        }
    }
}

// Example usage:
// const graph = {
//     0: [1, 2],
//     1: [0, 3, 4],
//     2: [0, 5],
//     3: [1],
//     4: [1, 5],
//     5: [2, 4]
// };
// dfsRecursive(graph, 0);</code></pre>
      </div>
      
      <p><strong>Practice Idea:</strong> Modify DFS to detect cycles in an undirected graph. Keep track of parent nodes to distinguish between back edges and parent edges. Return true if a cycle is detected, false otherwise.</p>
      
      <p><strong>Real-world Applications:</strong>
        <ul>
            <li><strong>Maze Solving:</strong> Finding paths through mazes and puzzles</li>
            <li><strong>Dependency Resolution:</strong> Used in build systems like Make to resolve dependencies</li>
            <li><strong>Cycle Detection:</strong> Finding cycles in graphs and networks</li>
            <li><strong>Topological Sorting:</strong> Arranging tasks with dependencies in linear order</li>
            <li><strong>Connected Components:</strong> Finding all connected components in a graph</li>
            <li><strong>Game AI:</strong> Pathfinding and decision trees in games</li>
            <li><strong>Web Crawling:</strong> Exploring links deeply before moving to other domains</li>
        </ul>
      </p>
      
      <p><strong>Summary:</strong> Depth-First Search is a fundamental graph traversal algorithm that explores deeply before backtracking. Its O(V+E) time complexity makes it efficient for graph problems, and its recursive nature makes it elegant to implement. While it may not find the shortest path like BFS, it's essential for many graph algorithms and serves as the foundation for more complex graph processing techniques.</p>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const languageButtons = document.querySelectorAll('.code-language-btn');
        const codeBlocks = document.querySelectorAll('.language-code-block');
        
        languageButtons.forEach(button => {
            button.addEventListener('click', function() {
                const targetLanguage = this.getAttribute('data-language');
                
                // Update active button
                languageButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                
                // Show corresponding code block
                codeBlocks.forEach(block => {
                    if (block.id === `${targetLanguage}-code`) {
                        block.classList.add('active');
                    } else {
                        block.classList.remove('active');
                    }
                });
            });
        });
    });
    </script>
</body>
</html>